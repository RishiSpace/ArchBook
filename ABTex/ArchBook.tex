\documentclass[12pt,openany]{book}

\usepackage[a4paper, margin=0.75in]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{titlesec}
\usepackage{parskip}
\usepackage{setspace}

\definecolor{codegray}{rgb}{0.95,0.95,0.95}
\definecolor{darkblue}{rgb}{0.0,0.0,0.5}

\lstset{
  backgroundcolor=\color{codegray},
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  showstringspaces=false,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{darkblue}
}

\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries}{\chaptername\ \thechapter}{20pt}{\Huge}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  urlcolor=blue,
  pdftitle={How to install Arch Linux},
  pdfauthor={Rishikesh Giridhar},
  pdfsubject={Arch Linux Guide},
  pdfkeywords={Arch Linux, Installation, Guide, Minimal, Unix}
}

\pagestyle{fancy}
\setlength{\headheight}{14.5pt} 
\fancyhf{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\nouppercase{\leftmark}}
\fancyhead[LO]{\nouppercase{\rightmark}}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{4cm}
    {\Huge\bfseries How to install Arch Linux \par}
    \vspace{1cm}
    {\Large A Barebones, Cheesy, yet No-Nonsense Guide \par}
    \vspace{2cm}
    {\Large \textit{by Rishikesh Giridhar} \par}
    \vfill
\end{titlepage}

\tableofcontents
\newpage

\chapter{Introduction}

\section*{You Think You Know Linux?}
\addcontentsline{toc}{section}{You Think You Know Linux?}

So, you‚Äôve used Linux before. Maybe Ubuntu. Maybe Mint. Fedora if you're feeling fancy. You‚Äôve clicked your way through an installer, watched as some wizard held your hand, and then said to yourself, ‚ÄúHey, I use Linux now.‚Äù

But here's the thing: you don‚Äôt.

Those aren‚Äôt Linux ‚Äî those are Linux-flavoured illusions. Training wheels bolted onto a tricycle, wrapped in bubble wrap. If you‚Äôve never written your own `fstab`, never mounted a root partition manually, never booted to a blinking cursor in a live environment and built your entire operating system line by line ‚Äî then you‚Äôve merely touched Linux. You‚Äôve never wielded it.

Enter Arch Linux.

\section*{Why Arch? Because You Want Control.}
\addcontentsline{toc}{section}{Why Arch? Because You Want Control.}

Other distributions try to guess what you want. Arch asks you.

Where others give you a desktop, Arch gives you a shell. Where others offer security through abstraction, Arch offers power through exposure. It is not ‚Äúuser-friendly‚Äù in the traditional sense, because its user is not the traditional type. Its user is someone like you ‚Äî curious, stubborn, tired of the coddling, and ready to truly understand how Linux works.

You don‚Äôt ‚Äúinstall‚Äù Arch. You earn it.

\section*{Because Minimalism Isn't a Style ‚Äî It's a Statement}
\addcontentsline{toc}{section}{Because Minimalism Isn't a Style ‚Äî It's a Statement}

Arch doesn't come with a GUI, and that‚Äôs not a bug ‚Äî it‚Äôs a feature. It installs only what you explicitly tell it to. No junk. No clipboard managers. No software centres. No 15 background services you never asked for. Just the kernel, the essentials, and you.

Want GNOME? Install it. Want i3? Build it. Want nothing but a terminal forever like a proper chad? Stay there.

Arch is as small or as expansive as you want it to be. You‚Äôre not fighting the system ‚Äî you‚Äôre designing it.

\section*{‚ÄúBut My Distro Just Works‚Äù ‚Äî Does It, Though?}
\addcontentsline{toc}{section}{‚ÄúBut My Distro Just Works‚Äù ‚Äî Does It, Though?}

Ah yes, the phrase that always precedes a help thread titled *‚ÄúWhy did my update break my desktop?‚Äù* You see, when your system is built from the ground up, when you know what every daemon, mount point, and config file is doing, then when something breaks, you don‚Äôt panic. You fix it.

Because you know it. Because you built it.

And updates? Arch is a rolling release ‚Äî not some outdated stable-core nonsense. You get the latest kernel, latest drivers, latest software, on your terms. You're not stuck six months behind waiting for some release freeze to thaw.

\section*{Gaslighting? No ‚Äî We‚Äôre Just Honest}
\addcontentsline{toc}{section}{Gaslighting? No ‚Äî We‚Äôre Just Honest}

Look, if you think your click-and-install distro is ‚Äúbasically the same‚Äù as Arch, that‚Äôs fine. You‚Äôre entitled to your beliefs, however adorably incorrect they might be.

But let‚Äôs be real.

When you say ‚ÄúI use Linux‚Äù and someone asks ‚ÄúOh, which distro?‚Äù, and you reply ‚ÄúArch‚Äù, the conversation ends. You win. Because everyone knows: the person who uses Arch doesn‚Äôt just use Linux ‚Äî they understand it. They command it.

You‚Äôre not someone running Linux.

You‚Äôre someone running Arch.

\section*{This Book Is Your Rite of Passage}
\addcontentsline{toc}{section}{This Book Is Your Rite of Passage}

This guide will walk you through every step: from downloading the ISO to booting into your newly forged Arch install. No fluff. No pre-chewed tutorials. Real commands. Real choices. Real Linux.

If you're not ready to get your hands dirty, turn back now. There are easier paths ‚Äî full of GUIs and safety nets. But if you're ready to see the truth behind the terminal, to graduate from ‚Äúuser‚Äù to ‚Äúbuilder‚Äù, then welcome.

This is where it starts.

\clearpage


\chapter{Preinstallation}

\section*{You Don't Just Install Arch. You Prepare For It.}
\addcontentsline{toc}{section}{You Don't Just Install Arch. You Prepare For It.}

Welcome to the stage before the stage. This is the part no one talks about. The part the ‚Äú5-minute YouTube Arch install‚Äù videos skip right over. But not you. You, brave reader, are here to do it properly.

This chapter is about preparation. Because installing Arch without proper setup is like parachuting with a trash bag ‚Äî it's bold, but also very stupid.

Let‚Äôs get into the meat.

\section*{Step 1: Downloading the ISO (Yes, Correctly)}
\addcontentsline{toc}{section}{Step 1: Downloading the ISO (Yes, Correctly)}

You‚Äôre going to download the official Arch Linux ISO image. Not from some dodgy Reddit mirror. From the source of all truth:

\begin{lstlisting}
https://archlinux.org/download
\end{lstlisting}

Once you open this link, you‚Äôll see a list of mirrors grouped by country. These are maintained by community and university hosts. Find your country, or the one closest to you geographically. For example:

\begin{itemize}
  \item If you're in India, select one of the IIT mirrors or TUNA (China) if faster.
  \item If you're in Europe, stick to local NLU or university mirrors (e.g., Germany ‚Üí TU Dresden).
  \item In the US? Use kernel.org, MIT, or OSL mirrors.
\end{itemize}

Once you choose your mirror, download the file named something like:

\begin{lstlisting}
archlinux-YYYY.MM.DD-x86_64.iso
\end{lstlisting}

Replace `YYYY.MM.DD` with the release date (e.g., `2025.07.01`).

\textbf{Also download the `.sig` file} ‚Äî this is the cryptographic signature used to verify the ISO is not tampered with.

\subsection*{Why We Verify:}

Yes, you really should verify the ISO. Here's why:

- The `.sig` file is signed with a GPG key owned by the Arch Linux release manager.
- If someone tampered with your ISO (hello, supply chain attacks), this check would fail.

\subsection*{How to Verify:}

First, get the key:
\begin{lstlisting}
gpg --keyserver hkps://keyserver.ubuntu.com --recv-keys 9766E084FB0F43D8
\end{lstlisting}

> `9766E084FB0F43D8` is the long-form fingerprint of the official Arch ISO signing key.

Then verify:
\begin{lstlisting}
gpg --verify archlinux-2025.07.01-x86_64.iso.sig
\end{lstlisting}

If the output says:

```

Good signature from "Pierre Schmitz [pierre@archlinux.org](mailto:pierre@archlinux.org)"

```
You're golden. If not, throw that ISO out like expired milk.

\section*{Step 2: Flashing the ISO to a USB Drive}
\addcontentsline{toc}{section}{Step 2: Flashing the ISO to a USB Drive}

\textbf{Do not ‚Äúopen the ISO‚Äù and copy its files. That‚Äôs not how bootable drives work.}

\subsection*{Option A: Windows ‚Äî Use Rufus (The Only Acceptable GUI Method)}

1. Download Rufus from: \url{https://rufus.ie}
2. Plug in your USB drive (at least 2GB).
3. Open Rufus ‚Üí Select your ISO.
4. \textbf{Important:} Choose ‚ÄúDD mode‚Äù if prompted. Not ‚ÄúISO mode.‚Äù
5. Start.

\subsection*{Option B: Linux ‚Äî Use dd (aka Disk Destroyer)}

\begin{lstlisting}
sudo dd if=archlinux-2025.07.01-x86_64.iso of=/dev/sdX bs=4M status=progress oflag=sync
\end{lstlisting}

- `if=` = input file (your ISO)
- `of=` = output file (your USB device, like `/dev/sdb` ‚Äî not a partition like `/dev/sdb1`)
- `bs=4M` = block size, optimal for speed
- `status=progress` = shows progress
- `oflag=sync` = ensures all writes are flushed to disk

Double check using `lsblk` to make sure `/dev/sdX` is really your USB drive.

\section*{Step 3: Boot Into the USB Drive (Not Your OS)}
\addcontentsline{toc}{section}{Step 3: Boot Into the USB Drive (Not Your OS)}

Insert the USB into your target machine.

Reboot and spam your BIOS/UEFI boot menu key (often `F12`, `F10`, `DEL`, `ESC`, or `F2`).

From the boot menu, select your USB device. If it says ‚ÄúUEFI: Sandisk‚Äù, pick that.

If it boots correctly, you'll see:

``
Arch Linux boot menu
Boot Arch Linux (x86\_64)
''


Select it and hit enter. You should land in a live shell.

If you land in a graphical installer, you downloaded the wrong distro. Reevaluate your life choices.

\section*{Step 4: UEFI or Legacy (Spoiler: It Better Be UEFI)}
\addcontentsline{toc}{section}{Step 4: UEFI or Legacy (Spoiler: It Better Be UEFI)}

We don't do BIOS installs in the year of our Lord 2025.

Check:
\begin{lstlisting}
ls /sys/firmware/efi/efivars
\end{lstlisting}

If the folder exists, you‚Äôre booted in UEFI mode.  
If not, reboot, enter your firmware settings, and enable:

\begin{itemize}
  \item ‚ÄúUEFI Mode‚Äù or ‚ÄúUEFI Only‚Äù
  \item Disable ‚ÄúLegacy Boot‚Äù or ‚ÄúCSM‚Äù
  \item Secure Boot: OFF (for now)
\end{itemize}

\section*{Step 5: Connect to the Internet}
\addcontentsline{toc}{section}{Step 5: Connect to the Internet}

\subsection*{A. Ethernet (Wired)? Lucky You. You're Already Online.}

To test:
\begin{lstlisting}
ping archlinux.org
\end{lstlisting}

If you get output with response times, you‚Äôre in.

\subsection*{B. Wi-Fi (You Like Pain)?}

First, start the `iwd` shell:
\begin{lstlisting}
iwctl
\end{lstlisting}

Then:

\begin{lstlisting}
device list                # See your wireless interface, e.g., wlan0
station wlan0 scan        # Scans nearby Wi-Fi
station wlan0 get-networks
station wlan0 connect YourWiFiName
\end{lstlisting}

You‚Äôll be prompted for your Wi-Fi password.  
If it fails, try again. If it keeps failing, check if:

- Your Wi-Fi is 5GHz-only and your adapter is 2.4GHz.
- You typed the password like a potato.
- You need to unblock the device: `rfkill unblock wifi`

\section*{Step 6: Sync the System Clock (Don‚Äôt Skip This!)}
\addcontentsline{toc}{section}{Step 6: Sync the System Clock (Don‚Äôt Skip This!)}

\begin{lstlisting}
timedatectl set-ntp true
\end{lstlisting}

This enables automatic time sync via NTP (Network Time Protocol). If your clock is wrong, `pacman` will cry, signatures will fail, and you‚Äôll blame Arch instead of yourself.

Check:
\begin{lstlisting}
timedatectl status
\end{lstlisting}

Look for:
``

System clock synchronized: yes

''

If it says ‚Äúno,‚Äù you‚Äôre probably offline or behind a captive portal.

\section*{Step 7: Identify Your Drives (Don't Wipe Windows Unless You Mean To)}
\addcontentsline{toc}{section}{Step 7: Identify Your Drives (Don't Wipe Windows Unless You Mean To)}

Use:
\begin{lstlisting}
lsblk
\end{lstlisting}

You'll see a tree of devices:

\begin{lstlisting}
NAME   MAJ\:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0 232.9G  0 disk
‚îú‚îÄsda1   8:1    0   512M  0 part
‚îú‚îÄsda2   8:2    0   100G  0 part
nvme0n1     259:0 0 476.9G 0 disk
‚îú‚îÄnvme0n1p1 259:1 0   512M 0 part
‚îú‚îÄnvme0n1p2 259:2 0 100.0G 0 part

\end{lstlisting}

- `sda`, `nvme0n1`, etc. are disks
- `sda1`, `nvme0n1p2` are partitions

You can also run:
\begin{lstlisting}
fdisk -l
\end{lstlisting}

Look at the sizes and filesystems. Windows partitions often show as `NTFS`. You‚Äôll want to install Arch on a separate disk or partition, or yeet the whole drive (with backups, obviously).

\section*{You Are Now Ready}
\addcontentsline{toc}{section}{You Are Now Ready}

Once you‚Äôve:

\begin{itemize}
  \item Booted via UEFI
  \item Verified and flashed the Arch ISO
  \item Connected to the internet
  \item Synced your clock
  \item Identified your disks
\end{itemize}

...you are officially standing at the gates of Arch.

Next up: slicing up your disk with precision using `fdisk` (and not screwing it up).

\clearpage


\chapter{Connecting to the Internet}

\section*{You Can‚Äôt Install Arch Offline. (Well, Technically You Can, But You Shouldn‚Äôt.)}
\addcontentsline{toc}{section}{You Can‚Äôt Install Arch Offline. (Well, Technically You Can, But You Shouldn‚Äôt.)}

The first thing any good Arch wizard does after booting into the live environment is ensure they are online. Why? Because you‚Äôre about to pull the entire base system from Arch repositories via `pacstrap`, and unless you've memorised every binary ever made (you haven't), you‚Äôll need the internet.

This chapter covers how to connect to the internet, whether you‚Äôre blessed with Ethernet or condemned to suffer through Wi-Fi.

\section{Wired Ethernet ‚Äî The True Master Race}

Let‚Äôs start with the easiest, most reliable method: plugging in a cable.

If your system is connected to a router via Ethernet, congratulations. You‚Äôre probably already online.

\subsection*{Step 1: Test the connection}

\begin{lstlisting}
ping archlinux.org
\end{lstlisting}

You should see a repeating output like:

\begin{lstlisting}
64 bytes from archlinux.org (95.217.163.246): icmp_seq=1 ttl=51 time=128 ms
\end{lstlisting}

To stop it, hit `Ctrl + C`.

If this works, you‚Äôre online. Proceed to the next chapter. Seriously. You're done here.

If not? The cable may be bad, your router may be dumb, or your DHCP isn't assigning IPs. Let‚Äôs troubleshoot later.

\section{Wireless ‚Äî The Path of Pain}

Connecting via Wi-Fi is possible ‚Äî just not as instant. You‚Äôll need to use the **IWD** (iNet Wireless Daemon) system included in the Arch ISO.

\subsection*{Step 1: Launch IWD interactive shell}

\begin{lstlisting}
iwctl
\end{lstlisting}

This opens the IWD shell. It should look something like:

\begin{lstlisting}
[iwd]#
\end{lstlisting}

If you see that, you're inside the network manager. If not, you may not have a supported wireless card.

\subsection*{Step 2: List wireless devices}

\begin{lstlisting}
device list
\end{lstlisting}

Look for something like:

\begin{lstlisting}
Device: wlan0
  Type: wifi
\end{lstlisting}

Take note of the interface name ‚Äî usually `wlan0`, `wlp3s0`, or `wlan1`. We‚Äôll use it below.

\subsection*{Step 3: Scan for networks}

\begin{lstlisting}
station wlan0 scan
\end{lstlisting}

(Replace `wlan0` with your actual device name if different.)

Then, list the results:

\begin{lstlisting}
station wlan0 get-networks
\end{lstlisting}

This will show a list of all nearby SSIDs.

\subsection*{Step 4: Connect to a network}

\begin{lstlisting}
station wlan0 connect YourWiFiSSID
\end{lstlisting}

> You‚Äôll be prompted for the password.

If it says "Connected", then congratulations ‚Äî you‚Äôre online.

\subsection*{Step 5: Exit the shell}

\begin{lstlisting}
exit
\end{lstlisting}

Now test connectivity:

\begin{lstlisting}
ping archlinux.org
\end{lstlisting}

If you see replies, it worked. If not? Read the next section.

\section{Common Wi-Fi Failures and Fixes}

\subsection*{1. ‚ÄúOperation Failed‚Äù or ‚ÄúNo Device‚Äù in iwctl?}

Run:

\begin{lstlisting}
rfkill list all
\end{lstlisting}

If any line shows ‚Äúsoft blocked: yes‚Äù or ‚Äúhard blocked: yes‚Äù, unblock it:

\begin{lstlisting}
rfkill unblock all
\end{lstlisting}

Then retry `iwctl`.

\subsection*{2. iwctl says connected but ping doesn‚Äôt work?}

Run:

\begin{lstlisting}
ip a
\end{lstlisting}

If you don‚Äôt see an IP address under your Wi-Fi interface, then DHCP failed. Try:

\begin{lstlisting}
systemctl restart iwd
\end{lstlisting}

Or restart the whole shell:

\begin{lstlisting}
exit
iwctl
\end{lstlisting}

Still nothing? Reboot and try again. Sometimes it‚Äôs the firmware (especially on Broadcom or Realtek cards).

\section{Legacy Option: wifi-menu (Only Available on netctl-based ISOs)}

Some very old Arch ISOs ship with `wifi-menu`:

\begin{lstlisting}
wifi-menu
\end{lstlisting}

This launches an ncurses-based selector for wireless networks. It‚Äôs deprecated and usually not present in modern ISOs, but if your ISO has it, and `iwctl` doesn‚Äôt work, give it a go.

\section{Using a Static IP (Edge Case or Emergency)}

If your router is broken, or you‚Äôre in a network without DHCP, you can assign a static IP manually.

Example:

\begin{lstlisting}
ip link set wlan0 up
ip addr add 192.168.1.100/24 dev wlan0
ip route add default via 192.168.1.1
\end{lstlisting}

Then set a DNS resolver:

\begin{lstlisting}
echo "nameserver 1.1.1.1" > /etc/resolv.conf
\end{lstlisting}

Now try `ping archlinux.org`.

\section{Confirming You‚Äôre Online}

No matter which method you used, always confirm with:

\begin{lstlisting}
ping archlinux.org
\end{lstlisting}

If that works, you're ready to install Arch.

If not, no shame in retrying ‚Äî but do not proceed until this works. No internet = no pacstrap = no Arch.

\clearpage

\chapter{Partitioning the Disk}

\section*{Look Me in the Eye and Tell Me You're Ready to Wipe a Drive}
\addcontentsline{toc}{section}{Look Me in the Eye and Tell Me You're Ready to Wipe a Drive}

This is it ‚Äî the point of no return. From here on out, you‚Äôre not just reading. You‚Äôre carving your will into silicon. One wrong device name and you might wipe your Windows partition, your family photos, your tax returns, and any shred of dignity.

Which is exactly why we‚Äôre going to do it right.

\section{The Boot Mode Dictates Your Partition Style}

Before anything else, make absolutely sure you‚Äôre booted in **UEFI mode**. Run:

\begin{lstlisting}
ls /sys/firmware/efi/efivars
\end{lstlisting}

If that directory exists ‚Äî you're good. Proceed with GPT partitioning (the modern standard).

If it doesn‚Äôt exist, you're in Legacy BIOS mode. That‚Äôs fine too (just worse). We‚Äôll handle that in a separate section.

\subsection*{Wait ‚Äî What‚Äôs GPT vs MBR?}

- **GPT (GUID Partition Table)**: Modern. Required for UEFI. Supports more than 4 partitions. Safer and better aligned.
- **MBR (Master Boot Record)**: Ancient BIOS format. Limited. Clunky. Avoid unless your firmware forces it.

Unless your PC is from the Jurassic era, use GPT.

\section{Identify the Target Disk (Don't Wipe the Wrong One)}

Run:

\begin{lstlisting}
lsblk
\end{lstlisting}

Example output:

\begin{lstlisting}
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda           8:0    0 232.9G  0 disk
nvme0n1     259:0    0 476.9G  0 disk
‚îú‚îÄnvme0n1p1 259:1    0   512M  0 part /boot
‚îú‚îÄnvme0n1p2 259:2    0   476G  0 part /
\end{lstlisting}

Look at the SIZE column. If you're installing onto a blank SSD, it's probably `/dev/sda` or `/dev/nvme0n1`.

If you‚Äôre unsure ‚Äî stop. Double check. Remove all drives except the one you want to install on.

\section{Partition Layout (UEFI Scheme)}

For a typical UEFI install, here‚Äôs what we want:

\begin{itemize}
  \item `/dev/sdX1` ‚Üí EFI System Partition (512MB, FAT32)
  \item `/dev/sdX2` ‚Üí Root (`/`) partition (rest of the disk, ext4)
  \item [Optional] `/dev/sdX3` ‚Üí Swap or Home
\end{itemize}

No need to overcomplicate it. One root partition is all Arch needs.

\section{Using \texttt{fdisk} (Beginner-Friendly, Deadly If You Panic)}

Start `fdisk`:

\begin{lstlisting}
fdisk /dev/sdX
\end{lstlisting}

Replace `/dev/sdX` with your actual disk. NOT a partition (e.g. NOT `/dev/sda1`).

\subsection*{Step-by-step fdisk (GPT Mode):}

1. Press `g` ‚Üí creates a new GPT partition table (wipes the drive)
2. Press `n` ‚Üí create new partition
   - Partition number: 1
   - First sector: press Enter
   - Last sector: `+512M`
   - Type: `t`, then type code: `1` (EFI System)
3. Press `n` again ‚Üí create root partition
   - Partition number: 2
   - Accept defaults for rest of disk
4. (Optional) Press `n` again ‚Üí swap partition
   - Set size like `+8G`
   - Set type to `19` (Linux swap)

Once done:

\begin{lstlisting}
w
\end{lstlisting}

`w` = write changes and exit. There is no undo.

\section{Using \texttt{cgdisk} (For Visual Learners Who Like Retro Interfaces)}

\begin{lstlisting}
cgdisk /dev/sdX
\end{lstlisting}

You‚Äôll get a TUI interface. It‚Äôs self-explanatory:

- Use arrows to select ‚ÄúNew‚Äù
- Type partition sizes like `512M`, `100\%`
- Set type codes:
  - `EF00` for EFI System
  - `8300` for Linux filesystem
  - `8200` for Linux swap

Write changes and exit.

\section{Formatting the Partitions}

Now that you‚Äôve sliced the disk, time to give them filesystems.

\subsection*{EFI Partition (FAT32):}

\begin{lstlisting}
mkfs.fat -F32 /dev/sdX1
\end{lstlisting}

\subsection*{Root Partition (ext4):}

\begin{lstlisting}
mkfs.ext4 /dev/sdX2
\end{lstlisting}

\subsection*{Optional: Swap Partition}

Create and activate it:

\begin{lstlisting}
mkswap /dev/sdX3
swapon /dev/sdX3
\end{lstlisting}

Note: Swap is optional. With 8GB+ RAM, you don‚Äôt really need it unless you plan to hibernate.

\section{Mounting the Filesystems}

Arch doesn't do this for you ‚Äî you must mount everything manually.

\begin{lstlisting}
mount /dev/sdX2 /mnt
mkdir /mnt/boot
mount /dev/sdX1 /mnt/boot
\end{lstlisting}

If you created a separate home partition:

\begin{lstlisting}
mkdir /mnt/home
mount /dev/sdX4 /mnt/home
\end{lstlisting}

At this point, your disk layout should look like this:

\begin{lstlisting}
/
‚îú‚îÄ‚îÄ boot      ‚Üí mounted from /dev/sdX1
‚îú‚îÄ‚îÄ (root)    ‚Üí mounted from /dev/sdX2
‚îú‚îÄ‚îÄ home      ‚Üí optionally /dev/sdX4
‚îî‚îÄ‚îÄ swap      ‚Üí activated via swapon
\end{lstlisting}

\section{Verify Mounts}

Run:

\begin{lstlisting}
lsblk -f
\mount | grep mnt
\end{lstlisting}

Make sure all mount points are correct. If not, unmount and try again.

\section{If You‚Äôre Using BIOS (MBR) Boot Instead...}

Rare, but here‚Äôs the rundown:

- Use `fdisk` with `o` to create a DOS partition table
- First partition: root (`/`) ‚Üí type 83 (Linux)
- Optional: second partition for swap ‚Üí type 82
- No EFI partition needed
- Format and mount as above

Note: You will use GRUB as your bootloader instead of systemd-boot.

\section{Final Checkpoint}

‚úÖ Drive is partitioned  
‚úÖ Filesystems are created  
‚úÖ Mount points are ready  
‚úÖ Swap is active (if used)  
‚úÖ You didn‚Äôt nuke the wrong disk

You're ready to `pacstrap` this beast into existence.

\clearpage


\chapter{Installing the Base System}

\section*{Time to Put Flesh on the Skeleton}

You‚Äôve prepped the disk. You‚Äôve mounted your partitions. `/mnt` is waiting ‚Äî hollow, empty, full of possibility.

Now comes the moment Arch veterans call ‚Äúpacstrapping.‚Äù This is where you install the base packages that form the foundation of your Linux system.

You‚Äôre not clicking checkboxes. You‚Äôre calling down the barest, rawest, most essential components of an operating system ‚Äî one that does exactly what you tell it to and absolutely nothing else.

\section{What is \texttt{pacstrap}?}

`pacstrap` is a special Arch install tool. It installs packages into a target root directory ‚Äî in our case, `/mnt`.

So, when you run:

\begin{lstlisting}
pacstrap -K /mnt base linux linux-firmware
\end{lstlisting}

Here‚Äôs what each part does:

- `-K`: Copies your current machine‚Äôs package signing keys to the target system (saves you a step later).
- `/mnt`: Target directory for the installation ‚Äî you previously mounted your root partition here.
- `base`: A metapackage that pulls in core utilities (`bash`, `coreutils`, `pacman`, `systemd`, etc.).
- `linux`: Installs the latest Arch kernel (you can swap this for `linux-lts` or `linux-zen` later).
- `linux-firmware`: Adds firmware blobs for hardware like Wi-Fi, audio, GPUs, etc.

\section{Minimal Example ‚Äî Barebones Install}

\begin{lstlisting}
pacstrap -K /mnt base linux linux-firmware
\end{lstlisting}

This is enough to boot, configure, and later install your user environment.

\section{Commonly Added Packages (Optional but Useful)}

You can also throw in:

\begin{lstlisting}
pacstrap -K /mnt base linux linux-firmware vim nano man-db man-pages texinfo
\end{lstlisting}

Explanation:

- `vim` or `nano`: Text editors. Choose your pain.
- `man-db`, `man-pages`, `texinfo`: Documentation. So you don‚Äôt have to Google how `mount` works at 3AM.

Want a network manager? You‚Äôll install that later, *inside* the chroot. Don‚Äôt worry about it now.

\section{What \texttt{/mnt} Is, Really}

Right now, `/mnt` is where your future system lives. Every command you give from this point forward that mentions `/mnt` is configuring your soon-to-be root filesystem.

When you chroot into it, `/mnt` will become `/`. You‚Äôll be inside your new system. But for now, we‚Äôre still outside ‚Äî gently crafting its skeleton.

\section{Creating the \texttt{fstab} ‚Äî The System's Map of Your Disk}

`fstab` tells the system how to mount disks and partitions automatically at boot.

To generate it:

\begin{lstlisting}
genfstab -U /mnt >> /mnt/etc/fstab
\end{lstlisting}

- `-U`: Uses UUIDs (universally unique identifiers) instead of `/dev/sdX` ‚Äî avoids confusion when device names change.
- `>>`: Appends output to the fstab file.
- `/mnt/etc/fstab`: The config file that gets created.

\subsection*{Verify It:}

Just to be safe, always check the file:

\begin{lstlisting}
cat /mnt/etc/fstab
\end{lstlisting}

You should see entries for `/`, `/boot`, and `swap` (if used), like:

\begin{lstlisting}
/dev/nvme0n1p2 UUID=abc123... / ext4 defaults 0 1
/dev/nvme0n1p1 UUID=def456... /boot vfat defaults 0 2
\end{lstlisting}

If anything looks wrong ‚Äî redo the mount and generate fstab again.

\section{Enter the Void: \texttt{arch-chroot}}

Now it‚Äôs time to step into your new system and take control.

\begin{lstlisting}
arch-chroot /mnt
\end{lstlisting}

You‚Äôll land in what looks like your usual shell, but you're now *inside* your installed system. You can configure it just like any regular Arch install from here.

From this point forward, any changes you make (like setting passwords, locale, hostname, installing packages) will be to your new system ‚Äî not the live ISO.

Welcome home, user. You‚Äôve built your skeleton.

\section*{Checklist Before Moving On}

‚úÖ `pacstrap` ran without errors  
‚úÖ `fstab` was generated and looks correct  
‚úÖ You can `arch-chroot` into the new system  
‚úÖ You understand `/mnt` is your root-to-be

If all that's done, you‚Äôre ready to give this beast a soul ‚Äî hostname, locale, time, users, bootloader, the lot. But that‚Äôs in the next chapter.

\clearpage


\chapter{System Configuration}

\section*{You've Built the Flesh. Now It Needs a Brain.}

You've chrooted into your fresh new Arch system. It knows nothing. It has no sense of time, no language, no name, no user. If you were to reboot now, you'd have a blank disk with a kernel that doesn't even know it exists.

Let‚Äôs fix that.

\section{Set the Time Zone}

Start by setting the system‚Äôs time zone. You don‚Äôt want your logs timestamped in UTC+Mars.

\subsection*{Find your time zone:}

\begin{lstlisting}
ls /usr/share/zoneinfo
\end{lstlisting}

This directory contains all time zones. Drill down into your region and city, e.g.:

\begin{lstlisting}
ls /usr/share/zoneinfo/Asia
\end{lstlisting}

Once you know yours (e.g., `Asia/Kolkata`), set it:

\begin{lstlisting}
ln -sf /usr/share/zoneinfo/Asia/Kolkata /etc/localtime
\end{lstlisting}

\subsection*{Sync the hardware clock:}

\begin{lstlisting}
hwclock --systohc
\end{lstlisting}

This sets the hardware clock (BIOS clock) to match the system time.

\section{Set Locale (Language + Encoding)}

Edit `/etc/locale.gen` to uncomment the locales you want.

\begin{lstlisting}
nano /etc/locale.gen
\end{lstlisting}

Find the line:

\begin{lstlisting}
#en_US.UTF-8 UTF-8
\end{lstlisting}

And remove the `#`:

\begin{lstlisting}
en_US.UTF-8 UTF-8
\end{lstlisting}

Save and exit (`Ctrl+O`, `Enter`, `Ctrl+X`).

Then generate the locales:

\begin{lstlisting}
locale-gen
\end{lstlisting}

\subsection*{Set default system language:}

Create or edit `/etc/locale.conf`:

\begin{lstlisting}
echo "LANG=en_US.UTF-8" > /etc/locale.conf
\end{lstlisting}

\section{Set the Hostname}

Pick a name for your machine. This will appear in your shell prompt, your SSH sessions, and every log file. It‚Äôs your system‚Äôs name in the realm.

\begin{lstlisting}
echo "archbeast" > /etc/hostname
\end{lstlisting}

\section{Configure /etc/hosts (Networking ID)}

Edit your hosts file to match your hostname:

\begin{lstlisting}
nano /etc/hosts
\end{lstlisting}

Add these lines:

\begin{lstlisting}
127.0.0.1    localhost
::1          localhost
127.0.1.1    archbeast.localdomain archbeast
\end{lstlisting}

Replace `archbeast` with your actual hostname.

\section{Set Root Password}

\begin{lstlisting}
passwd
\end{lstlisting}

Enter and confirm your root password. Choose wisely. You‚Äôre root ‚Äî the god of this system.

\section{Create a Non-Root User}

Root is powerful ‚Äî too powerful. You‚Äôll want a regular user.

\begin{lstlisting}
useradd -m -G wheel -s /bin/bash rishi
\end{lstlisting}

This creates a user named `rishi`:
- `-m`: makes a home directory
- `-G wheel`: adds to the `wheel` group (for sudo access)
- `-s /bin/bash`: sets the shell

Set the user‚Äôs password:

\begin{lstlisting}
passwd rishi
\end{lstlisting}

\section{Enable \texttt{sudo} for Wheel Group}

First, install sudo:

\begin{lstlisting}
pacman -S sudo
\end{lstlisting}

Then edit the sudoers file with:

\begin{lstlisting}
EDITOR=nano visudo
\end{lstlisting}

Find the line:

\begin{lstlisting}
# %wheel ALL=(ALL:ALL) ALL
\end{lstlisting}

Uncomment it (remove the `#`).

Now any user in the `wheel` group can use `sudo`.

\section{Install Networking Tools}

Let‚Äôs install tools so you can connect to the internet after reboot.

\begin{lstlisting}
pacman -S networkmanager
\end{lstlisting}

Enable it for boot:

\begin{lstlisting}
systemctl enable NetworkManager
\end{lstlisting}

This gives you Wi-Fi/Ethernet management out of the box.

\section{Install Text Editor (Because You‚Äôll Need One)}

Pick your poison:

\begin{lstlisting}
pacman -S vim
\end{lstlisting}
or
\begin{lstlisting}
pacman -S nano
\end{lstlisting}

Nano is easier, Vim is better (if you know it).

\section{Generate initramfs (Boot Image)}

This step generates the initramfs ‚Äî a compressed archive that boots your kernel and mounts the root file system.

Usually this happens automatically with `pacstrap`, but let‚Äôs be sure:

\begin{lstlisting}
mkinitcpio -P
\end{lstlisting}

That‚Äôs it. Your system is now configured to boot and function.

Next up? The bootloader. Yes, the thing that makes your system show up when you turn it on.

\clearpage



\chapter{Bootloader Setup}

\section*{This Is Where the Magic Happens}

You‚Äôve got a fully configured root filesystem, a working kernel, and an initramfs image ready to roll. But if you reboot now? Nothing happens.

That‚Äôs because we haven‚Äôt installed the bootloader ‚Äî the sacred whisperer that tells your firmware where to find your OS.

Let‚Äôs fix that.

\section{Option A: systemd-boot (UEFI Only, Arch Approved)}

This is the cleanest, fastest bootloader for UEFI systems. It integrates tightly with systemd and doesn't carry GRUB‚Äôs bloaty legacy.

\subsection*{Step 1: Ensure You‚Äôre in UEFI Mode}

Just double check, again:

\begin{lstlisting}
ls /sys/firmware/efi/efivars
\end{lstlisting}

If it‚Äôs empty or missing, stop ‚Äî you need to use GRUB instead (jump to Section B).

\subsection*{Step 2: Install systemd-boot}

\begin{lstlisting}
bootctl install
\end{lstlisting}

This installs `systemd-boot` into your EFI system partition (`/boot`), assuming you mounted `/dev/sdX1` to `/boot` earlier (as instructed).

You should see:

\begin{lstlisting}
Created "/boot/EFI/systemd".
Copied "/usr/lib/systemd/boot/efi/systemd-bootx64.efi" ‚Üí "/boot/EFI/systemd/systemd-bootx64.efi".
Created EFI boot entry.
\end{lstlisting}

\subsection*{Step 3: Create the Loader Configuration File}

Create `/boot/loader/loader.conf`:

\begin{lstlisting}
nano /boot/loader/loader.conf
\end{lstlisting}

Add the following:

\begin{lstlisting}
default arch
timeout 3
console-mode max
editor no
\end{lstlisting}

- `default arch`: Sets which entry boots by default
- `timeout`: How long the bootloader waits before auto-boot
- `console-mode max`: Makes the font less potato
- `editor no`: Disables editing the boot entry mid-boot

\subsection*{Step 4: Create the Boot Entry}

Create a file at `/boot/loader/entries/arch.conf`:

\begin{lstlisting}
nano /boot/loader/entries/arch.conf
\end{lstlisting}

Paste this:

\begin{lstlisting}
title   Arch Linux
linux   /vmlinuz-linux
initrd  /initramfs-linux.img
options root=UUID=your-root-uuid-here rw
\end{lstlisting}

Now get your root partition‚Äôs UUID:

\begin{lstlisting}
blkid
\end{lstlisting}

Find the line for your root partition (e.g., `/dev/sda2`) and copy its UUID. Replace `your-root-uuid-here` with it (keep the UUID in the same format).

Your final entry might look like:

\begin{lstlisting}
options root=UUID=abc1234-5678-dead-beef-1234567890ab rw
\end{lstlisting}

You‚Äôre done. That‚Äôs it. When you reboot, systemd-boot will pick up your entry and boot Arch.

\section{Option B: GRUB (UEFI or Legacy BIOS)}

If you‚Äôre stuck with BIOS, or you dual-boot Windows, or your firmware is allergic to simplicity, you‚Äôll need GRUB.

\subsection*{Step 1: Install GRUB and Required Tools}

\begin{lstlisting}
pacman -S grub efibootmgr dosfstools os-prober mtools
\end{lstlisting}

- `efibootmgr`: Required for UEFI
- `os-prober`: Detects other OSes (Windows, other Linux distros)
- `mtools`, `dosfstools`: Required to work with FAT partitions (EFI)

\subsection*{Step 2A: UEFI GRUB Installation}

\begin{lstlisting}
grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB
\end{lstlisting}

\subsection*{Step 2B: BIOS GRUB Installation}

\begin{lstlisting}
grub-install --target=i386-pc /dev/sdX
\end{lstlisting}

Where `/dev/sdX` is your disk, *not* a partition (e.g., `/dev/sda` not `/dev/sda1`).

\subsection*{Step 3: Generate GRUB Config}

\begin{lstlisting}
grub-mkconfig -o /boot/grub/grub.cfg
\end{lstlisting}

You‚Äôll see it scanning for kernels and other OSes. If you installed `os-prober`, it might pick up Windows or another Linux install.

And with that, you have a bootloader.

\section{Checkpoint: Ready for Reboot?}

Make sure:

- systemd-boot or GRUB is installed
- You‚Äôve created at least one boot entry
- `blkid` shows UUIDs and they match your config
- Your boot partition is correctly mounted

Now‚Ä¶ exit and unmount:

\begin{lstlisting}
exit
umount -R /mnt
\end{lstlisting}

Then finally:

\begin{lstlisting}
reboot
\end{lstlisting}

If all goes well, your screen will flash black, your heart will skip, and then you‚Äôll see the **Arch Linux** bootloader screen.

Welcome to the club.

\clearpage


\chapter{Post-Install Essentials}

\section*{It Boots. Now Let‚Äôs Make It Functional.}

Congrats. If you‚Äôve made it this far, you‚Äôve done more than 90\% of the world ever will. Your Arch system boots. It breathes. But it doesn‚Äôt yet *live*.

This chapter is about giving it the basic tools it needs to become a daily driver. We‚Äôre not talking KDE Plasma or i3 just yet ‚Äî we‚Äôre talking **drivers**, **microcode**, **audio**, and a few **sane defaults**.

\section{Update Everything}

Even though `pacstrap` installed the latest snapshot, package updates can happen hourly. Best to start clean.

\begin{lstlisting}
pacman -Syu
\end{lstlisting}

This updates all packages to the current latest from the Arch mirrors.

\section{Install CPU Microcode (Do Not Skip)}

Microcode is firmware for your CPU. Yes, even the brain of your machine ships buggy code. We fix that here.

\subsection*{For Intel CPUs:}

\begin{lstlisting}
pacman -S intel-ucode
\end{lstlisting}

Then edit your `arch.conf` (if using systemd-boot):

\begin{lstlisting}
nano /boot/loader/entries/arch.conf
\end{lstlisting}

Add this **above** the `initrd /initramfs-linux.img` line:

\begin{lstlisting}
initrd /intel-ucode.img
\end{lstlisting}

\subsection*{For AMD CPUs:}

\begin{lstlisting}
pacman -S amd-ucode
\end{lstlisting}

Same edit applies in your boot entry.

This ensures your CPU gets updated microcode at boot ‚Äî crucial for stability and performance.

\section{Audio ‚Äî Because Silence is for Windows Users}

Arch uses `pipewire` ‚Äî the superior modern replacement for PulseAudio.

\begin{lstlisting}
pacman -S pipewire pipewire-alsa pipewire-pulse pipewire-jack wireplumber
\end{lstlisting}

Then enable the audio service:

\begin{lstlisting}
systemctl enable --now pipewire pipewire-pulse wireplumber
\end{lstlisting}

Test later with:

\begin{lstlisting}
speaker-test -c 2
\end{lstlisting}

\section{Graphics Drivers ‚Äî Know Your GPU}

Without a graphics driver, your system will feel like a potato in a freezer.

\subsection*{Intel (Integrated Graphics):}

\begin{lstlisting}
pacman -S xf86-video-intel mesa vulkan-intel libva-intel-driver
\end{lstlisting}

\subsection*{AMD (Radeon/VEGA):}

\begin{lstlisting}
pacman -S xf86-video-amdgpu mesa vulkan-radeon libva-mesa-driver
\end{lstlisting}

\subsection*{NVIDIA (Dedicated Cards):}

\begin{lstlisting}
pacman -S nvidia nvidia-utils nvidia-settings
\end{lstlisting}

Also run:

\begin{lstlisting}
nvidia-modprobe
\end{lstlisting}

> üí° You don‚Äôt need `xf86-video-vesa`. That‚Äôs a fallback and usually worse.

\section{Bluetooth (If You Need It)}

\begin{lstlisting}
pacman -S bluez bluez-utils
systemctl enable --now bluetooth
\end{lstlisting}

Use `bluetoothctl` for pairing devices from terminal.

\section{Printing (For Those Who Still Use Paper)}

\begin{lstlisting}
pacman -S cups system-config-printer
systemctl enable --now cups
\end{lstlisting}

CUPS is the printing daemon. Works with most USB/WiFi printers via GUI once DE is installed.

\section{Network Tools (Optional, But Helpful)}

\begin{lstlisting}
pacman -S wget curl git
\end{lstlisting}

Useful for fetching things, cloning dotfiles, and surviving in general.

\section{Basic Terminal + GUI Tools}

\subsection*{File Manager (CLI):}

\begin{lstlisting}
pacman -S ranger
\end{lstlisting}

\subsection*{Terminal Emulators:}

\begin{lstlisting}
pacman -S alacritty kitty
\end{lstlisting}

\subsection*{Fonts:}

\begin{lstlisting}
pacman -S ttf-dejavu ttf-liberation noto-fonts
\end{lstlisting}

Trust me ‚Äî install fonts before your DE. Otherwise half the UI will look like corrupted boxes.

\section{Optional: Enable Reflector for Faster Mirrors}

Faster mirrors = faster installs/updates. Install and enable reflector:

\begin{lstlisting}
pacman -S reflector
\end{lstlisting}

Then enable the mirror ranking service:

\begin{lstlisting}
systemctl enable reflector.timer
\end{lstlisting}

You can also manually update mirrors:

\begin{lstlisting}
reflector --latest 10 --protocol https --sort rate --save /etc/pacman.d/mirrorlist
\end{lstlisting}

\section{Checkpoint Before Graphical Setup}

‚úÖ System updated  
‚úÖ Microcode installed  
‚úÖ Audio working via pipewire  
‚úÖ Graphics drivers installed  
‚úÖ Bluetooth and printing services ready  
‚úÖ Fonts and terminal tools in place  

You're now ready for a display server and a desktop environment ‚Äî a throne for your new OS.

\clearpage


\chapter{Graphical Environment Setup}

\section*{CLI is Pure, But GUI is Useful}

Yes, the terminal is a sacred rite. But there comes a time to bless your Arch system with **vision** ‚Äî a graphical environment.

In this chapter:

\begin{enumerate}
  \item We‚Äôll install a display server (Wayland-first, X11 optional)
  \item Choose a desktop environment or window manager
  \item Set up a display/login manager or `startx`
\end{enumerate}

\section{Wayland is Now}

Wayland is no longer the future ‚Äî it‚Äôs the present. It‚Äôs the default for GNOME, KDE Plasma, and others.

X11 is still supported, but it's only used:
\begin{itemize}
  \item For legacy apps or WMs
  \item When Wayland has known compatibility issues
\end{itemize}

Unless you have a specific need, stick to **Wayland**.

\section{Installing Wayland (if not bundled)}

Most DEs (GNOME, KDE) bring Wayland along. But to be explicit:

\begin{lstlisting}
pacman -S wayland xdg-desktop-portal xdg-desktop-portal-wlr
\end{lstlisting}

Note: Some portals are DE-specific ‚Äî GNOME/KDE pull their own.

\section{Installing a Desktop Environment (Wayland-First Choices)}

\subsection*{Option A: KDE Plasma 6 (Now Wayland by Default)}

\begin{lstlisting}
pacman -S plasma-meta kde-applications qt6-wayland
pacman -S sddm
systemctl enable sddm
\end{lstlisting}

Wayland will be default. If you ever want to switch to X11, just select it from the SDDM session menu.

\subsection*{Option B: GNOME (Wayland Default)}

\begin{lstlisting}
pacman -S gnome gnome-extra
systemctl enable gdm
\end{lstlisting}

GDM launches into Wayland by default. No config needed.

\subsection*{Option C: Sway (Wayland-native i3 Alternative)}

\begin{lstlisting}
pacman -S sway alacritty foot wl-clipboard xwayland
\end{lstlisting}

Sway is a tiling window manager for Wayland. `xwayland` allows legacy X apps to run.

You can launch Sway from TTY:

\begin{lstlisting}
exec sway
\end{lstlisting}

\subsection*{Option D: XFCE (X11 Only, for Now)}

\begin{lstlisting}
pacman -S xfce4 xfce4-goodies
pacman -S lightdm lightdm-gtk-greeter
systemctl enable lightdm
\end{lstlisting}

Still stuck on X11, but extremely lightweight.

\section{Display Manager vs startx}

- A **Display Manager** gives you a GUI login screen.
- `startx` (X11) or `exec sway` (Wayland) are CLI launch options.

If you're using GNOME or KDE: use GDM or SDDM.  
If using a Wayland WM like Sway, you can launch manually from TTY.

\subsection*{Make GUI login default:}

\begin{lstlisting}
systemctl set-default graphical.target
\end{lstlisting}

\section{Fonts and Themes}

Always install fonts before launching a DE:

\begin{lstlisting}
pacman -S ttf-dejavu ttf-liberation noto-fonts ttf-nerd-fonts-symbols
\end{lstlisting}

GTK/Qt Theme config:

\begin{lstlisting}
pacman -S lxappearance qt5ct qt6ct
\end{lstlisting}

\section{Post-DE Checklist}

‚úÖ Wayland installed and used by default  
‚úÖ GNOME/KDE auto-launch with GDM/SDDM  
‚úÖ Fonts and themes configured  
‚úÖ Display target set to graphical  
‚úÖ You can launch into GUI on boot (or via TTY for Sway)

You now wield a **Wayland-powered** desktop Arch system. You didn‚Äôt just install an OS ‚Äî you cultivated a kingdom.

\clearpage

\chapter{Precepts of the Arch Faithful}

\section*{Before You Install, Understand What You're Installing}

Most people blindly click ‚ÄúNext‚Äù through installers and never know what makes their system tick. But Arch Linux doesn‚Äôt do *‚ÄúNext‚Äù*.

This chapter is your **deep dive** into what makes your system **boot, breathe, draw, and obey**.

\section{1. The Kernel ‚Äî The Soul of the System}

At its heart, Linux is **just the kernel** ‚Äî the core software that talks to your hardware and manages your system's resources.

The kernel does things like:

\begin{itemize}
  \item Handling memory (RAM allocation)
  \item Scheduling CPU tasks
  \item Managing I/O (input/output to devices)
  \item Enabling hardware features (Wi-Fi, USB, Graphics, etc.)
\end{itemize}

In Arch, the default kernel is `linux`, but you can also choose others:

\begin{itemize}
  \item `linux-lts` ‚Äì Long-term support
  \item `linux-zen` ‚Äì Optimised for performance
  \item `linux-hardened` ‚Äì Enhanced security
\end{itemize}

The kernel is stored in `/boot/vmlinuz-linux` and gets loaded at boot time via your bootloader (systemd-boot, GRUB, etc.)

\section{2. initramfs ‚Äî The Bridge to the Kernel}

When your system boots, it doesn‚Äôt jump straight into the root file system. It first loads a temporary one: **initramfs** (Initial RAM Filesystem).

This small image:
\begin{itemize}
  \item Loads essential drivers (like filesystem, encryption, LVM)
  \item Mounts the real root partition
  \item Hands control over to the actual system (`/`)
\end{itemize}

It's created using `mkinitcpio`, and lives at `/boot/initramfs-linux.img`.

\section{3. systemd ‚Äî The Grand Orchestrator}

Once your kernel and root filesystem are live, you need someone to **start services**, manage your login sessions, handle daemons, and coordinate boot stages.

That‚Äôs where `systemd` comes in.

It replaces the old SysV-style init system and:
\begin{itemize}
  \item Manages services like networking, display manager, audio, etc.
  \item Handles dependencies (e.g., NetworkManager starts before KDE)
  \item Provides logging via `journalctl`
  \item Supports parallel boot for faster startup
\end{itemize}

You‚Äôll use it all the time:
\begin{lstlisting}
systemctl enable bluetooth
systemctl start NetworkManager
systemctl set-default graphical.target
\end{lstlisting}

\section{4. Shell and Terminal ‚Äî Your First Interface}

The shell is the interface that interprets your commands. It‚Äôs not the terminal itself ‚Äî it‚Äôs the program running *inside* the terminal.

\begin{itemize}
  \item `bash` ‚Äì Default shell, most common
  \item `zsh` ‚Äì Fancy shell with themes and plugins
  \item `fish` ‚Äì User-friendly shell with autosuggestions
\end{itemize}

The **terminal emulator** is the GUI program that gives you access to the shell ‚Äî like `alacritty`, `gnome-terminal`, `konsole`, etc.

\section{5. Display Server ‚Äî How Graphics Get Drawn}

You can‚Äôt show windows without a display server.

\subsection*{X11 (xorg)}

The original. Decades old. Works fine. Supported everywhere. But:

\begin{itemize}
  \item No security between apps
  \item Janky multi-monitor support
  \item Doesn't scale well on HiDPI screens
\end{itemize}

\subsection*{Wayland (Modern Default)}

The new standard. Used by GNOME, KDE, Sway, Hyprland.

\begin{itemize}
  \item Per-app security and isolation
  \item Tear-free rendering
  \item Fractional scaling works properly
  \item Compositing is built-in
\end{itemize}

Arch supports both ‚Äî but Wayland is the **default for modern systems**.

\section{6. Desktop Environment ‚Äî The Furniture of Your OS}

A Desktop Environment (DE) is a full suite of software that gives you a graphical experience:

\begin{itemize}
  \item A window manager (to place and move windows)
  \item Panels, app launchers, system tray, settings
  \item Themes, compositors, wallpapers, login screen
\end{itemize}

Examples:

\begin{itemize}
  \item \textbf{GNOME} ‚Äî Opinionated, Wayland-first, great out of the box
  \item \textbf{KDE Plasma} ‚Äî Customisable to death, fast and beautiful
  \item \textbf{XFCE} ‚Äî Lightweight and no-nonsense
  \item \textbf{i3/Sway} ‚Äî Tiling WMs for keyboard gods
\end{itemize}

You can even build your own DE from just a WM + panel + launcher.

\section{7. How Arch Works ‚Äî Rolling, Minimal, Transparent}

Arch Linux has no versions. You install once, update forever.

\begin{itemize}
  \item Rolling release model: updates are constant, not periodic
  \item No default DE: you install only what you want
  \item Pacman: powerful package manager
  \item AUR: community-contributed packages (via `yay`, `paru`, etc.)
  \item ArchWiki: best documentation on Earth (literally)
\end{itemize}

There are no defaults, no assumptions. You are the architect.

\section{8. Why the Install is Manual (And Why It Matters)}

You‚Äôve already noticed: installing Arch is not plug-and-play.

That‚Äôs by design.

\begin{itemize}
  \item You learn every step ‚Äî from partitioning to bootloading
  \item You know exactly what‚Äôs installed (no bloat)
  \item You fix your own system because you understand it
\end{itemize}

Once installed, your Arch system is:
\begin{itemize}
  \item Minimal ‚Äî nothing you didn‚Äôt ask for
  \item Bleeding edge ‚Äî always the latest Linux tech
  \item Totally yours ‚Äî configured how *you* want
\end{itemize}

\clearpage

\end{document}
