\documentclass[12pt]{book}

\usepackage[a4paper, margin=0.75in]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{titlesec}
\usepackage{parskip}
\usepackage{setspace}

\definecolor{codegray}{rgb}{0.95,0.95,0.95}
\definecolor{darkblue}{rgb}{0.0,0.0,0.5}

\lstset{
  backgroundcolor=\color{codegray},
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  showstringspaces=false,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{darkblue}
}

\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries}{\chaptername\ \thechapter}{20pt}{\Huge}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  urlcolor=blue,
  pdftitle={How to install Arch Linux},
  pdfauthor={Rishikesh Giridhar},
  pdfsubject={Arch Linux Guide},
  pdfkeywords={Arch Linux, Installation, Guide, Minimal, Unix}
}

\pagestyle{fancy}
\setlength{\headheight}{14.5pt} % <-- Add this line
\fancyhf{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\nouppercase{\leftmark}}
\fancyhead[LO]{\nouppercase{\rightmark}}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{4cm}
    {\Huge\bfseries How to install Arch Linux \par}
    \vspace{1cm}
    {\Large A Barebones, No-Nonsense Guide \par}
    \vspace{2cm}
    {\Large \textit{by Rishikesh Giridhar} \par}
    \vfill
    {\large \today \par}
\end{titlepage}

\tableofcontents
\newpage

\chapter{Introduction}

\section*{You Think You Know Linux?}

So, youâ€™ve used Linux before. Maybe Ubuntu. Maybe Mint. Fedora if you're feeling fancy. Youâ€™ve clicked your way through an installer, watched as some wizard held your hand, and then said to yourself, â€œHey, I use Linux now.â€

But here's the thing: you donâ€™t.

Those arenâ€™t Linux â€” those are Linux-flavoured illusions. Training wheels bolted onto a tricycle, wrapped in bubble wrap. If youâ€™ve never written your own `fstab`, never mounted a root partition manually, never booted to a blinking cursor in a live environment and built your entire operating system line by line â€” then youâ€™ve merely touched Linux. Youâ€™ve never wielded it.

Enter Arch Linux.

\section*{Why Arch? Because You Want Control.}

Other distributions try to guess what you want. Arch asks you.

Where others give you a desktop, Arch gives you a shell. Where others offer security through abstraction, Arch offers power through exposure. It is not â€œuser-friendlyâ€ in the traditional sense, because its user is not the traditional type. Its user is someone like you â€” curious, stubborn, tired of the coddling, and ready to truly understand how Linux works.

You donâ€™t â€œinstallâ€ Arch. You earn it.

\section*{Because Minimalism Isn't a Style â€” It's a Statement}

Arch doesn't come with a GUI, and thatâ€™s not a bug â€” itâ€™s a feature. It installs only what you explicitly tell it to. No junk. No clipboard managers. No software centres. No 15 background services you never asked for. Just the kernel, the essentials, and you.

Want GNOME? Install it. Want i3? Build it. Want nothing but a terminal forever like a proper chad? Stay there.

Arch is as small or as expansive as you want it to be. Youâ€™re not fighting the system â€” youâ€™re designing it.

\section*{â€œBut My Distro Just Worksâ€ â€” Does It, Though?}

Ah yes, the phrase that always precedes a help thread titled *â€œWhy did my update break my desktop?â€* You see, when your system is built from the ground up, when you know what every daemon, mount point, and config file is doing, then when something breaks, you donâ€™t panic. You fix it.

Because you know it. Because you built it.

And updates? Arch is a rolling release â€” not some outdated stable-core nonsense. You get the latest kernel, latest drivers, latest software, on your terms. You're not stuck six months behind waiting for some release freeze to thaw.

\section*{Gaslighting? No â€” Weâ€™re Just Honest}

Look, if you think your click-and-install distro is â€œbasically the sameâ€ as Arch, thatâ€™s fine. Youâ€™re entitled to your beliefs, however adorably incorrect they might be.

But letâ€™s be real.

When you say â€œI use Linuxâ€ and someone asks â€œOh, which distro?â€, and you reply â€œArchâ€, the conversation ends. You win. Because everyone knows: the person who uses Arch doesnâ€™t just use Linux â€” they understand it. They command it.

Youâ€™re not someone running Linux.

Youâ€™re someone running Arch.

\section*{This Book Is Your Rite of Passage}

This guide will walk you through every step: from downloading the ISO to booting into your newly forged Arch install. No fluff. No pre-chewed tutorials. Real commands. Real choices. Real Linux.

If you're not ready to get your hands dirty, turn back now. There are easier paths â€” full of GUIs and safety nets. But if you're ready to see the truth behind the terminal, to graduate from â€œuserâ€ to â€œbuilderâ€, then welcome.

This is where it starts.

\clearpage


\chapter{Preinstallation}

\section*{You Don't Just Install Arch. You Prepare For It.}

Welcome to the stage before the stage. This is the part no one talks about. The part the â€œ5-minute YouTube Arch installâ€ videos skip right over. But not you. You, brave reader, are here to do it properly.

This chapter is about preparation. Because installing Arch without proper setup is like parachuting with a trash bag â€” it's bold, but also very stupid.

Letâ€™s get into the meat.

\section*{Step 1: Downloading the ISO (Yes, Correctly)}

Youâ€™re going to download the official Arch Linux ISO image. Not from some dodgy Reddit mirror. From the source of all truth:

\begin{lstlisting}
https://archlinux.org/download
\end{lstlisting}

Once you open this link, youâ€™ll see a list of mirrors grouped by country. These are maintained by community and university hosts. Find your country, or the one closest to you geographically. For example:

\begin{itemize}
  \item If you're in India, select one of the IIT mirrors or TUNA (China) if faster.
  \item If you're in Europe, stick to local NLU or university mirrors (e.g., Germany â†’ TU Dresden).
  \item In the US? Use kernel.org, MIT, or OSL mirrors.
\end{itemize}

Once you choose your mirror, download the file named something like:

\begin{lstlisting}
archlinux-YYYY.MM.DD-x86_64.iso
\end{lstlisting}

Replace `YYYY.MM.DD` with the release date (e.g., `2025.07.01`).

\textbf{Also download the `.sig` file} â€” this is the cryptographic signature used to verify the ISO is not tampered with.

\subsection*{Why We Verify:}

Yes, you really should verify the ISO. Here's why:

- The `.sig` file is signed with a GPG key owned by the Arch Linux release manager.
- If someone tampered with your ISO (hello, supply chain attacks), this check would fail.

\subsection*{How to Verify:}

First, get the key:
\begin{lstlisting}
gpg --keyserver hkps://keyserver.ubuntu.com --recv-keys 9766E084FB0F43D8
\end{lstlisting}

> `9766E084FB0F43D8` is the long-form fingerprint of the official Arch ISO signing key.

Then verify:
\begin{lstlisting}
gpg --verify archlinux-2025.07.01-x86_64.iso.sig
\end{lstlisting}

If the output says:
```

Good signature from "Pierre Schmitz [pierre@archlinux.org](mailto:pierre@archlinux.org)"

```
You're golden. If not, throw that ISO out like expired milk.

\section*{Step 2: Flashing the ISO to a USB Drive}

\textbf{Do not â€œopen the ISOâ€ and copy its files. Thatâ€™s not how bootable drives work.}

\subsection*{Option A: Windows â€” Use Rufus (The Only Acceptable GUI Method)}

1. Download Rufus from: \url{https://rufus.ie}
2. Plug in your USB drive (at least 2GB).
3. Open Rufus â†’ Select your ISO.
4. \textbf{Important:} Choose â€œDD modeâ€ if prompted. Not â€œISO mode.â€
5. Start.

\subsection*{Option B: Linux â€” Use dd (aka Disk Destroyer)}

\begin{lstlisting}
sudo dd if=archlinux-2025.07.01-x86_64.iso of=/dev/sdX bs=4M status=progress oflag=sync
\end{lstlisting}

- `if=` = input file (your ISO)
- `of=` = output file (your USB device, like `/dev/sdb` â€” not a partition like `/dev/sdb1`)
- `bs=4M` = block size, optimal for speed
- `status=progress` = shows progress
- `oflag=sync` = ensures all writes are flushed to disk

Double check using `lsblk` to make sure `/dev/sdX` is really your USB drive.

\section*{Step 3: Boot Into the USB Drive (Not Your OS)}

Insert the USB into your target machine.

Reboot and spam your BIOS/UEFI boot menu key (often `F12`, `F10`, `DEL`, `ESC`, or `F2`).

From the boot menu, select your USB device. If it says â€œUEFI: Sandiskâ€, pick that.

If it boots correctly, you'll see:

``
Arch Linux boot menu
Boot Arch Linux (x86\_64)
''


Select it and hit enter. You should land in a live shell.

If you land in a graphical installer, you downloaded the wrong distro. Reevaluate your life choices.

\section*{Step 4: UEFI or Legacy (Spoiler: It Better Be UEFI)}

We don't do BIOS installs in the year of our Lord 2025.

Check:
\begin{lstlisting}
ls /sys/firmware/efi/efivars
\end{lstlisting}

If the folder exists, youâ€™re booted in UEFI mode.  
If not, reboot, enter your firmware settings, and enable:

\begin{itemize}
  \item â€œUEFI Modeâ€ or â€œUEFI Onlyâ€
  \item Disable â€œLegacy Bootâ€ or â€œCSMâ€
  \item Secure Boot: OFF (for now)
\end{itemize}

\section*{Step 5: Connect to the Internet}

\subsection*{A. Ethernet (Wired)? Lucky You. You're Already Online.}

To test:
\begin{lstlisting}
ping archlinux.org
\end{lstlisting}

If you get output with response times, youâ€™re in.

\subsection*{B. Wi-Fi (You Like Pain)?}

First, start the `iwd` shell:
\begin{lstlisting}
iwctl
\end{lstlisting}

Then:

\begin{lstlisting}
device list                # See your wireless interface, e.g., wlan0
station wlan0 scan        # Scans nearby Wi-Fi
station wlan0 get-networks
station wlan0 connect YourWiFiName
\end{lstlisting}

Youâ€™ll be prompted for your Wi-Fi password.  
If it fails, try again. If it keeps failing, check if:

- Your Wi-Fi is 5GHz-only and your adapter is 2.4GHz.
- You typed the password like a potato.
- You need to unblock the device: `rfkill unblock wifi`

\section*{Step 6: Sync the System Clock (Donâ€™t Skip This!)}

\begin{lstlisting}
timedatectl set-ntp true
\end{lstlisting}

This enables automatic time sync via NTP (Network Time Protocol). If your clock is wrong, `pacman` will cry, signatures will fail, and youâ€™ll blame Arch instead of yourself.

Check:
\begin{lstlisting}
timedatectl status
\end{lstlisting}

Look for:
``

System clock synchronized: yes

''

If it says â€œno,â€ youâ€™re probably offline or behind a captive portal.

\section*{Step 7: Identify Your Drives (Don't Wipe Windows Unless You Mean To)}

Use:
\begin{lstlisting}
lsblk
\end{lstlisting}

You'll see a tree of devices:

\begin{lstlisting}
NAME   MAJ\:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0 232.9G  0 disk
â”œâ”€sda1   8:1    0   512M  0 part
â”œâ”€sda2   8:2    0   100G  0 part
nvme0n1     259:0 0 476.9G 0 disk
â”œâ”€nvme0n1p1 259:1 0   512M 0 part
â”œâ”€nvme0n1p2 259:2 0 100.0G 0 part

\end{lstlisting}

- `sda`, `nvme0n1`, etc. are disks
- `sda1`, `nvme0n1p2` are partitions

You can also run:
\begin{lstlisting}
fdisk -l
\end{lstlisting}

Look at the sizes and filesystems. Windows partitions often show as `NTFS`. Youâ€™ll want to install Arch on a separate disk or partition, or yeet the whole drive (with backups, obviously).

\section*{You Are Now Ready}

Once youâ€™ve:

\begin{itemize}
  \item Booted via UEFI
  \item Verified and flashed the Arch ISO
  \item Connected to the internet
  \item Synced your clock
  \item Identified your disks
\end{itemize}

...you are officially standing at the gates of Arch.

Next up: slicing up your disk with precision using `fdisk` (and not screwing it up).

\clearpage


\chapter{Connecting to the Internet}

\section*{You Canâ€™t Install Arch Offline. (Well, Technically You Can, But You Shouldnâ€™t.)}

The first thing any good Arch wizard does after booting into the live environment is ensure they are online. Why? Because youâ€™re about to pull the entire base system from Arch repositories via `pacstrap`, and unless you've memorised every binary ever made (you haven't), youâ€™ll need the internet.

This chapter covers how to connect to the internet, whether youâ€™re blessed with Ethernet or condemned to suffer through Wi-Fi.

\section{Wired Ethernet â€” The True Master Race}

Letâ€™s start with the easiest, most reliable method: plugging in a cable.

If your system is connected to a router via Ethernet, congratulations. Youâ€™re probably already online.

\subsection*{Step 1: Test the connection}

\begin{lstlisting}
ping archlinux.org
\end{lstlisting}

You should see a repeating output like:

\begin{lstlisting}
64 bytes from archlinux.org (95.217.163.246): icmp_seq=1 ttl=51 time=128 ms
\end{lstlisting}

To stop it, hit `Ctrl + C`.

If this works, youâ€™re online. Proceed to the next chapter. Seriously. You're done here.

If not? The cable may be bad, your router may be dumb, or your DHCP isn't assigning IPs. Letâ€™s troubleshoot later.

\section{Wireless â€” The Path of Pain}

Connecting via Wi-Fi is possible â€” just not as instant. Youâ€™ll need to use the **IWD** (iNet Wireless Daemon) system included in the Arch ISO.

\subsection*{Step 1: Launch IWD interactive shell}

\begin{lstlisting}
iwctl
\end{lstlisting}

This opens the IWD shell. It should look something like:

\begin{lstlisting}
[iwd]#
\end{lstlisting}

If you see that, you're inside the network manager. If not, you may not have a supported wireless card.

\subsection*{Step 2: List wireless devices}

\begin{lstlisting}
device list
\end{lstlisting}

Look for something like:

\begin{lstlisting}
Device: wlan0
  Type: wifi
\end{lstlisting}

Take note of the interface name â€” usually `wlan0`, `wlp3s0`, or `wlan1`. Weâ€™ll use it below.

\subsection*{Step 3: Scan for networks}

\begin{lstlisting}
station wlan0 scan
\end{lstlisting}

(Replace `wlan0` with your actual device name if different.)

Then, list the results:

\begin{lstlisting}
station wlan0 get-networks
\end{lstlisting}

This will show a list of all nearby SSIDs.

\subsection*{Step 4: Connect to a network}

\begin{lstlisting}
station wlan0 connect YourWiFiSSID
\end{lstlisting}

> Youâ€™ll be prompted for the password.

If it says "Connected", then congratulations â€” youâ€™re online.

\subsection*{Step 5: Exit the shell}

\begin{lstlisting}
exit
\end{lstlisting}

Now test connectivity:

\begin{lstlisting}
ping archlinux.org
\end{lstlisting}

If you see replies, it worked. If not? Read the next section.

\section{Common Wi-Fi Failures and Fixes}

\subsection*{1. â€œOperation Failedâ€ or â€œNo Deviceâ€ in iwctl?}

Run:

\begin{lstlisting}
rfkill list all
\end{lstlisting}

If any line shows â€œsoft blocked: yesâ€ or â€œhard blocked: yesâ€, unblock it:

\begin{lstlisting}
rfkill unblock all
\end{lstlisting}

Then retry `iwctl`.

\subsection*{2. iwctl says connected but ping doesnâ€™t work?}

Run:

\begin{lstlisting}
ip a
\end{lstlisting}

If you donâ€™t see an IP address under your Wi-Fi interface, then DHCP failed. Try:

\begin{lstlisting}
systemctl restart iwd
\end{lstlisting}

Or restart the whole shell:

\begin{lstlisting}
exit
iwctl
\end{lstlisting}

Still nothing? Reboot and try again. Sometimes itâ€™s the firmware (especially on Broadcom or Realtek cards).

\section{Legacy Option: wifi-menu (Only Available on netctl-based ISOs)}

Some very old Arch ISOs ship with `wifi-menu`:

\begin{lstlisting}
wifi-menu
\end{lstlisting}

This launches an ncurses-based selector for wireless networks. Itâ€™s deprecated and usually not present in modern ISOs, but if your ISO has it, and `iwctl` doesnâ€™t work, give it a go.

\section{Using a Static IP (Edge Case or Emergency)}

If your router is broken, or youâ€™re in a network without DHCP, you can assign a static IP manually.

Example:

\begin{lstlisting}
ip link set wlan0 up
ip addr add 192.168.1.100/24 dev wlan0
ip route add default via 192.168.1.1
\end{lstlisting}

Then set a DNS resolver:

\begin{lstlisting}
echo "nameserver 1.1.1.1" > /etc/resolv.conf
\end{lstlisting}

Now try `ping archlinux.org`.

\section{Confirming Youâ€™re Online}

No matter which method you used, always confirm with:

\begin{lstlisting}
ping archlinux.org
\end{lstlisting}

If that works, you're ready to install Arch.

If not, no shame in retrying â€” but do not proceed until this works. No internet = no pacstrap = no Arch.

\clearpage

\chapter{Partitioning the Disk}

\section*{Look Me in the Eye and Tell Me You're Ready to Wipe a Drive}

This is it â€” the point of no return. From here on out, youâ€™re not just reading. Youâ€™re carving your will into silicon. One wrong device name and you might wipe your Windows partition, your family photos, your tax returns, and any shred of dignity.

Which is exactly why weâ€™re going to do it right.

\section{The Boot Mode Dictates Your Partition Style}

Before anything else, make absolutely sure youâ€™re booted in **UEFI mode**. Run:

\begin{lstlisting}
ls /sys/firmware/efi/efivars
\end{lstlisting}

If that directory exists â€” you're good. Proceed with GPT partitioning (the modern standard).

If it doesnâ€™t exist, you're in Legacy BIOS mode. Thatâ€™s fine too (just worse). Weâ€™ll handle that in a separate section.

\subsection*{Wait â€” Whatâ€™s GPT vs MBR?}

- **GPT (GUID Partition Table)**: Modern. Required for UEFI. Supports more than 4 partitions. Safer and better aligned.
- **MBR (Master Boot Record)**: Ancient BIOS format. Limited. Clunky. Avoid unless your firmware forces it.

Unless your PC is from the Jurassic era, use GPT.

\section{Identify the Target Disk (Don't Wipe the Wrong One)}

Run:

\begin{lstlisting}
lsblk
\end{lstlisting}

Example output:

\begin{lstlisting}
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda           8:0    0 232.9G  0 disk
nvme0n1     259:0    0 476.9G  0 disk
â”œâ”€nvme0n1p1 259:1    0   512M  0 part /boot
â”œâ”€nvme0n1p2 259:2    0   476G  0 part /
\end{lstlisting}

Look at the SIZE column. If you're installing onto a blank SSD, it's probably `/dev/sda` or `/dev/nvme0n1`.

If youâ€™re unsure â€” stop. Double check. Remove all drives except the one you want to install on.

\section{Partition Layout (UEFI Scheme)}

For a typical UEFI install, hereâ€™s what we want:

\begin{itemize}
  \item `/dev/sdX1` â†’ EFI System Partition (512MB, FAT32)
  \item `/dev/sdX2` â†’ Root (`/`) partition (rest of the disk, ext4)
  \item [Optional] `/dev/sdX3` â†’ Swap or Home
\end{itemize}

No need to overcomplicate it. One root partition is all Arch needs.

\section{Using \texttt{fdisk} (Beginner-Friendly, Deadly If You Panic)}

Start `fdisk`:

\begin{lstlisting}
fdisk /dev/sdX
\end{lstlisting}

Replace `/dev/sdX` with your actual disk. NOT a partition (e.g. NOT `/dev/sda1`).

\subsection*{Step-by-step fdisk (GPT Mode):}

1. Press `g` â†’ creates a new GPT partition table (wipes the drive)
2. Press `n` â†’ create new partition
   - Partition number: 1
   - First sector: press Enter
   - Last sector: `+512M`
   - Type: `t`, then type code: `1` (EFI System)
3. Press `n` again â†’ create root partition
   - Partition number: 2
   - Accept defaults for rest of disk
4. (Optional) Press `n` again â†’ swap partition
   - Set size like `+8G`
   - Set type to `19` (Linux swap)

Once done:

\begin{lstlisting}
w
\end{lstlisting}

`w` = write changes and exit. There is no undo.

\section{Using \texttt{cgdisk} (For Visual Learners Who Like Retro Interfaces)}

\begin{lstlisting}
cgdisk /dev/sdX
\end{lstlisting}

Youâ€™ll get a TUI interface. Itâ€™s self-explanatory:

- Use arrows to select â€œNewâ€
- Type partition sizes like `512M`, `100\%`
- Set type codes:
  - `EF00` for EFI System
  - `8300` for Linux filesystem
  - `8200` for Linux swap

Write changes and exit.

\section{Formatting the Partitions}

Now that youâ€™ve sliced the disk, time to give them filesystems.

\subsection*{EFI Partition (FAT32):}

\begin{lstlisting}
mkfs.fat -F32 /dev/sdX1
\end{lstlisting}

\subsection*{Root Partition (ext4):}

\begin{lstlisting}
mkfs.ext4 /dev/sdX2
\end{lstlisting}

\subsection*{Optional: Swap Partition}

Create and activate it:

\begin{lstlisting}
mkswap /dev/sdX3
swapon /dev/sdX3
\end{lstlisting}

Note: Swap is optional. With 8GB+ RAM, you donâ€™t really need it unless you plan to hibernate.

\section{Mounting the Filesystems}

Arch doesn't do this for you â€” you must mount everything manually.

\begin{lstlisting}
mount /dev/sdX2 /mnt
mkdir /mnt/boot
mount /dev/sdX1 /mnt/boot
\end{lstlisting}

If you created a separate home partition:

\begin{lstlisting}
mkdir /mnt/home
mount /dev/sdX4 /mnt/home
\end{lstlisting}

At this point, your disk layout should look like this:

\begin{lstlisting}
/
â”œâ”€â”€ boot      â†’ mounted from /dev/sdX1
â”œâ”€â”€ (root)    â†’ mounted from /dev/sdX2
â”œâ”€â”€ home      â†’ optionally /dev/sdX4
â””â”€â”€ swap      â†’ activated via swapon
\end{lstlisting}

\section{Verify Mounts}

Run:

\begin{lstlisting}
lsblk -f
\mount | grep mnt
\end{lstlisting}

Make sure all mount points are correct. If not, unmount and try again.

\section{If Youâ€™re Using BIOS (MBR) Boot Instead...}

Rare, but hereâ€™s the rundown:

- Use `fdisk` with `o` to create a DOS partition table
- First partition: root (`/`) â†’ type 83 (Linux)
- Optional: second partition for swap â†’ type 82
- No EFI partition needed
- Format and mount as above

Note: You will use GRUB as your bootloader instead of systemd-boot.

\section{Final Checkpoint}

âœ… Drive is partitioned  
âœ… Filesystems are created  
âœ… Mount points are ready  
âœ… Swap is active (if used)  
âœ… You didnâ€™t nuke the wrong disk

You're ready to `pacstrap` this beast into existence.

\clearpage


\chapter{Installing the Base System}

\section*{Time to Put Flesh on the Skeleton}

Youâ€™ve prepped the disk. Youâ€™ve mounted your partitions. `/mnt` is waiting â€” hollow, empty, full of possibility.

Now comes the moment Arch veterans call â€œpacstrapping.â€ This is where you install the base packages that form the foundation of your Linux system.

Youâ€™re not clicking checkboxes. Youâ€™re calling down the barest, rawest, most essential components of an operating system â€” one that does exactly what you tell it to and absolutely nothing else.

\section{What is \texttt{pacstrap}?}

`pacstrap` is a special Arch install tool. It installs packages into a target root directory â€” in our case, `/mnt`.

So, when you run:

\begin{lstlisting}
pacstrap -K /mnt base linux linux-firmware
\end{lstlisting}

Hereâ€™s what each part does:

- `-K`: Copies your current machineâ€™s package signing keys to the target system (saves you a step later).
- `/mnt`: Target directory for the installation â€” you previously mounted your root partition here.
- `base`: A metapackage that pulls in core utilities (`bash`, `coreutils`, `pacman`, `systemd`, etc.).
- `linux`: Installs the latest Arch kernel (you can swap this for `linux-lts` or `linux-zen` later).
- `linux-firmware`: Adds firmware blobs for hardware like Wi-Fi, audio, GPUs, etc.

\section{Minimal Example â€” Barebones Install}

\begin{lstlisting}
pacstrap -K /mnt base linux linux-firmware
\end{lstlisting}

This is enough to boot, configure, and later install your user environment.

\section{Commonly Added Packages (Optional but Useful)}

You can also throw in:

\begin{lstlisting}
pacstrap -K /mnt base linux linux-firmware vim nano man-db man-pages texinfo
\end{lstlisting}

Explanation:

- `vim` or `nano`: Text editors. Choose your pain.
- `man-db`, `man-pages`, `texinfo`: Documentation. So you donâ€™t have to Google how `mount` works at 3AM.

Want a network manager? Youâ€™ll install that later, *inside* the chroot. Donâ€™t worry about it now.

\section{What \texttt{/mnt} Is, Really}

Right now, `/mnt` is where your future system lives. Every command you give from this point forward that mentions `/mnt` is configuring your soon-to-be root filesystem.

When you chroot into it, `/mnt` will become `/`. Youâ€™ll be inside your new system. But for now, weâ€™re still outside â€” gently crafting its skeleton.

\section{Creating the \texttt{fstab} â€” The System's Map of Your Disk}

`fstab` tells the system how to mount disks and partitions automatically at boot.

To generate it:

\begin{lstlisting}
genfstab -U /mnt >> /mnt/etc/fstab
\end{lstlisting}

- `-U`: Uses UUIDs (universally unique identifiers) instead of `/dev/sdX` â€” avoids confusion when device names change.
- `>>`: Appends output to the fstab file.
- `/mnt/etc/fstab`: The config file that gets created.

\subsection*{Verify It:}

Just to be safe, always check the file:

\begin{lstlisting}
cat /mnt/etc/fstab
\end{lstlisting}

You should see entries for `/`, `/boot`, and `swap` (if used), like:

\begin{lstlisting}
/dev/nvme0n1p2 UUID=abc123... / ext4 defaults 0 1
/dev/nvme0n1p1 UUID=def456... /boot vfat defaults 0 2
\end{lstlisting}

If anything looks wrong â€” redo the mount and generate fstab again.

\section{Enter the Void: \texttt{arch-chroot}}

Now itâ€™s time to step into your new system and take control.

\begin{lstlisting}
arch-chroot /mnt
\end{lstlisting}

Youâ€™ll land in what looks like your usual shell, but you're now *inside* your installed system. You can configure it just like any regular Arch install from here.

From this point forward, any changes you make (like setting passwords, locale, hostname, installing packages) will be to your new system â€” not the live ISO.

Welcome home, user. Youâ€™ve built your skeleton.

\section*{Checklist Before Moving On}

âœ… `pacstrap` ran without errors  
âœ… `fstab` was generated and looks correct  
âœ… You can `arch-chroot` into the new system  
âœ… You understand `/mnt` is your root-to-be

If all that's done, youâ€™re ready to give this beast a soul â€” hostname, locale, time, users, bootloader, the lot. But thatâ€™s in the next chapter.

\clearpage


\chapter{System Configuration}

\section*{You've Built the Flesh. Now It Needs a Brain.}

You've chrooted into your fresh new Arch system. It knows nothing. It has no sense of time, no language, no name, no user. If you were to reboot now, you'd have a blank disk with a kernel that doesn't even know it exists.

Letâ€™s fix that.

\section{Set the Time Zone}

Start by setting the systemâ€™s time zone. You donâ€™t want your logs timestamped in UTC+Mars.

\subsection*{Find your time zone:}

\begin{lstlisting}
ls /usr/share/zoneinfo
\end{lstlisting}

This directory contains all time zones. Drill down into your region and city, e.g.:

\begin{lstlisting}
ls /usr/share/zoneinfo/Asia
\end{lstlisting}

Once you know yours (e.g., `Asia/Kolkata`), set it:

\begin{lstlisting}
ln -sf /usr/share/zoneinfo/Asia/Kolkata /etc/localtime
\end{lstlisting}

\subsection*{Sync the hardware clock:}

\begin{lstlisting}
hwclock --systohc
\end{lstlisting}

This sets the hardware clock (BIOS clock) to match the system time.

\section{Set Locale (Language + Encoding)}

Edit `/etc/locale.gen` to uncomment the locales you want.

\begin{lstlisting}
nano /etc/locale.gen
\end{lstlisting}

Find the line:

\begin{lstlisting}
#en_US.UTF-8 UTF-8
\end{lstlisting}

And remove the `#`:

\begin{lstlisting}
en_US.UTF-8 UTF-8
\end{lstlisting}

Save and exit (`Ctrl+O`, `Enter`, `Ctrl+X`).

Then generate the locales:

\begin{lstlisting}
locale-gen
\end{lstlisting}

\subsection*{Set default system language:}

Create or edit `/etc/locale.conf`:

\begin{lstlisting}
echo "LANG=en_US.UTF-8" > /etc/locale.conf
\end{lstlisting}

\section{Set the Hostname}

Pick a name for your machine. This will appear in your shell prompt, your SSH sessions, and every log file. Itâ€™s your systemâ€™s name in the realm.

\begin{lstlisting}
echo "archbeast" > /etc/hostname
\end{lstlisting}

\section{Configure /etc/hosts (Networking ID)}

Edit your hosts file to match your hostname:

\begin{lstlisting}
nano /etc/hosts
\end{lstlisting}

Add these lines:

\begin{lstlisting}
127.0.0.1    localhost
::1          localhost
127.0.1.1    archbeast.localdomain archbeast
\end{lstlisting}

Replace `archbeast` with your actual hostname.

\section{Set Root Password}

\begin{lstlisting}
passwd
\end{lstlisting}

Enter and confirm your root password. Choose wisely. Youâ€™re root â€” the god of this system.

\section{Create a Non-Root User}

Root is powerful â€” too powerful. Youâ€™ll want a regular user.

\begin{lstlisting}
useradd -m -G wheel -s /bin/bash rishi
\end{lstlisting}

This creates a user named `rishi`:
- `-m`: makes a home directory
- `-G wheel`: adds to the `wheel` group (for sudo access)
- `-s /bin/bash`: sets the shell

Set the userâ€™s password:

\begin{lstlisting}
passwd rishi
\end{lstlisting}

\section{Enable \texttt{sudo} for Wheel Group}

First, install sudo:

\begin{lstlisting}
pacman -S sudo
\end{lstlisting}

Then edit the sudoers file with:

\begin{lstlisting}
EDITOR=nano visudo
\end{lstlisting}

Find the line:

\begin{lstlisting}
# %wheel ALL=(ALL:ALL) ALL
\end{lstlisting}

Uncomment it (remove the `#`).

Now any user in the `wheel` group can use `sudo`.

\section{Install Networking Tools}

Letâ€™s install tools so you can connect to the internet after reboot.

\begin{lstlisting}
pacman -S networkmanager
\end{lstlisting}

Enable it for boot:

\begin{lstlisting}
systemctl enable NetworkManager
\end{lstlisting}

This gives you Wi-Fi/Ethernet management out of the box.

\section{Install Text Editor (Because Youâ€™ll Need One)}

Pick your poison:

\begin{lstlisting}
pacman -S vim
\end{lstlisting}
or
\begin{lstlisting}
pacman -S nano
\end{lstlisting}

Nano is easier, Vim is better (if you know it).

\section{Generate initramfs (Boot Image)}

This step generates the initramfs â€” a compressed archive that boots your kernel and mounts the root file system.

Usually this happens automatically with `pacstrap`, but letâ€™s be sure:

\begin{lstlisting}
mkinitcpio -P
\end{lstlisting}

Thatâ€™s it. Your system is now configured to boot and function.

Next up? The bootloader. Yes, the thing that makes your system show up when you turn it on.

\clearpage



\chapter{Bootloader Setup}

\section*{This Is Where the Magic Happens}

Youâ€™ve got a fully configured root filesystem, a working kernel, and an initramfs image ready to roll. But if you reboot now? Nothing happens.

Thatâ€™s because we havenâ€™t installed the bootloader â€” the sacred whisperer that tells your firmware where to find your OS.

Letâ€™s fix that.

\section{Option A: systemd-boot (UEFI Only, Arch Approved)}

This is the cleanest, fastest bootloader for UEFI systems. It integrates tightly with systemd and doesn't carry GRUBâ€™s bloaty legacy.

\subsection*{Step 1: Ensure Youâ€™re in UEFI Mode}

Just double check, again:

\begin{lstlisting}
ls /sys/firmware/efi/efivars
\end{lstlisting}

If itâ€™s empty or missing, stop â€” you need to use GRUB instead (jump to Section B).

\subsection*{Step 2: Install systemd-boot}

\begin{lstlisting}
bootctl install
\end{lstlisting}

This installs `systemd-boot` into your EFI system partition (`/boot`), assuming you mounted `/dev/sdX1` to `/boot` earlier (as instructed).

You should see:

\begin{lstlisting}
Created "/boot/EFI/systemd".
Copied "/usr/lib/systemd/boot/efi/systemd-bootx64.efi" â†’ "/boot/EFI/systemd/systemd-bootx64.efi".
Created EFI boot entry.
\end{lstlisting}

\subsection*{Step 3: Create the Loader Configuration File}

Create `/boot/loader/loader.conf`:

\begin{lstlisting}
nano /boot/loader/loader.conf
\end{lstlisting}

Add the following:

\begin{lstlisting}
default arch
timeout 3
console-mode max
editor no
\end{lstlisting}

- `default arch`: Sets which entry boots by default
- `timeout`: How long the bootloader waits before auto-boot
- `console-mode max`: Makes the font less potato
- `editor no`: Disables editing the boot entry mid-boot

\subsection*{Step 4: Create the Boot Entry}

Create a file at `/boot/loader/entries/arch.conf`:

\begin{lstlisting}
nano /boot/loader/entries/arch.conf
\end{lstlisting}

Paste this:

\begin{lstlisting}
title   Arch Linux
linux   /vmlinuz-linux
initrd  /initramfs-linux.img
options root=UUID=your-root-uuid-here rw
\end{lstlisting}

Now get your root partitionâ€™s UUID:

\begin{lstlisting}
blkid
\end{lstlisting}

Find the line for your root partition (e.g., `/dev/sda2`) and copy its UUID. Replace `your-root-uuid-here` with it (keep the UUID in the same format).

Your final entry might look like:

\begin{lstlisting}
options root=UUID=abc1234-5678-dead-beef-1234567890ab rw
\end{lstlisting}

Youâ€™re done. Thatâ€™s it. When you reboot, systemd-boot will pick up your entry and boot Arch.

\section{Option B: GRUB (UEFI or Legacy BIOS)}

If youâ€™re stuck with BIOS, or you dual-boot Windows, or your firmware is allergic to simplicity, youâ€™ll need GRUB.

\subsection*{Step 1: Install GRUB and Required Tools}

\begin{lstlisting}
pacman -S grub efibootmgr dosfstools os-prober mtools
\end{lstlisting}

- `efibootmgr`: Required for UEFI
- `os-prober`: Detects other OSes (Windows, other Linux distros)
- `mtools`, `dosfstools`: Required to work with FAT partitions (EFI)

\subsection*{Step 2A: UEFI GRUB Installation}

\begin{lstlisting}
grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB
\end{lstlisting}

\subsection*{Step 2B: BIOS GRUB Installation}

\begin{lstlisting}
grub-install --target=i386-pc /dev/sdX
\end{lstlisting}

Where `/dev/sdX` is your disk, *not* a partition (e.g., `/dev/sda` not `/dev/sda1`).

\subsection*{Step 3: Generate GRUB Config}

\begin{lstlisting}
grub-mkconfig -o /boot/grub/grub.cfg
\end{lstlisting}

Youâ€™ll see it scanning for kernels and other OSes. If you installed `os-prober`, it might pick up Windows or another Linux install.

And with that, you have a bootloader.

\section{Checkpoint: Ready for Reboot?}

Make sure:

- systemd-boot or GRUB is installed
- Youâ€™ve created at least one boot entry
- `blkid` shows UUIDs and they match your config
- Your boot partition is correctly mounted

Nowâ€¦ exit and unmount:

\begin{lstlisting}
exit
umount -R /mnt
\end{lstlisting}

Then finally:

\begin{lstlisting}
reboot
\end{lstlisting}

If all goes well, your screen will flash black, your heart will skip, and then youâ€™ll see the **Arch Linux** bootloader screen.

Welcome to the club.

\clearpage


\chapter{Post-Install Essentials}

\section*{It Boots. Now Letâ€™s Make It Functional.}

Congrats. If youâ€™ve made it this far, youâ€™ve done more than 90\% of the world ever will. Your Arch system boots. It breathes. But it doesnâ€™t yet *live*.

This chapter is about giving it the basic tools it needs to become a daily driver. Weâ€™re not talking KDE Plasma or i3 just yet â€” weâ€™re talking **drivers**, **microcode**, **audio**, and a few **sane defaults**.

\section{Update Everything}

Even though `pacstrap` installed the latest snapshot, package updates can happen hourly. Best to start clean.

\begin{lstlisting}
pacman -Syu
\end{lstlisting}

This updates all packages to the current latest from the Arch mirrors.

\section{Install CPU Microcode (Do Not Skip)}

Microcode is firmware for your CPU. Yes, even the brain of your machine ships buggy code. We fix that here.

\subsection*{For Intel CPUs:}

\begin{lstlisting}
pacman -S intel-ucode
\end{lstlisting}

Then edit your `arch.conf` (if using systemd-boot):

\begin{lstlisting}
nano /boot/loader/entries/arch.conf
\end{lstlisting}

Add this **above** the `initrd /initramfs-linux.img` line:

\begin{lstlisting}
initrd /intel-ucode.img
\end{lstlisting}

\subsection*{For AMD CPUs:}

\begin{lstlisting}
pacman -S amd-ucode
\end{lstlisting}

Same edit applies in your boot entry.

This ensures your CPU gets updated microcode at boot â€” crucial for stability and performance.

\section{Audio â€” Because Silence is for Windows Users}

Arch uses `pipewire` â€” the superior modern replacement for PulseAudio.

\begin{lstlisting}
pacman -S pipewire pipewire-alsa pipewire-pulse pipewire-jack wireplumber
\end{lstlisting}

Then enable the audio service:

\begin{lstlisting}
systemctl enable --now pipewire pipewire-pulse wireplumber
\end{lstlisting}

Test later with:

\begin{lstlisting}
speaker-test -c 2
\end{lstlisting}

\section{Graphics Drivers â€” Know Your GPU}

Without a graphics driver, your system will feel like a potato in a freezer.

\subsection*{Intel (Integrated Graphics):}

\begin{lstlisting}
pacman -S xf86-video-intel mesa vulkan-intel libva-intel-driver
\end{lstlisting}

\subsection*{AMD (Radeon/VEGA):}

\begin{lstlisting}
pacman -S xf86-video-amdgpu mesa vulkan-radeon libva-mesa-driver
\end{lstlisting}

\subsection*{NVIDIA (Dedicated Cards):}

\begin{lstlisting}
pacman -S nvidia nvidia-utils nvidia-settings
\end{lstlisting}

Also run:

\begin{lstlisting}
nvidia-modprobe
\end{lstlisting}

> ðŸ’¡ You donâ€™t need `xf86-video-vesa`. Thatâ€™s a fallback and usually worse.

\section{Bluetooth (If You Need It)}

\begin{lstlisting}
pacman -S bluez bluez-utils
systemctl enable --now bluetooth
\end{lstlisting}

Use `bluetoothctl` for pairing devices from terminal.

\section{Printing (For Those Who Still Use Paper)}

\begin{lstlisting}
pacman -S cups system-config-printer
systemctl enable --now cups
\end{lstlisting}

CUPS is the printing daemon. Works with most USB/WiFi printers via GUI once DE is installed.

\section{Network Tools (Optional, But Helpful)}

\begin{lstlisting}
pacman -S wget curl git
\end{lstlisting}

Useful for fetching things, cloning dotfiles, and surviving in general.

\section{Basic Terminal + GUI Tools}

\subsection*{File Manager (CLI):}

\begin{lstlisting}
pacman -S ranger
\end{lstlisting}

\subsection*{Terminal Emulators:}

\begin{lstlisting}
pacman -S alacritty kitty
\end{lstlisting}

\subsection*{Fonts:}

\begin{lstlisting}
pacman -S ttf-dejavu ttf-liberation noto-fonts
\end{lstlisting}

Trust me â€” install fonts before your DE. Otherwise half the UI will look like corrupted boxes.

\section{Optional: Enable Reflector for Faster Mirrors}

Faster mirrors = faster installs/updates. Install and enable reflector:

\begin{lstlisting}
pacman -S reflector
\end{lstlisting}

Then enable the mirror ranking service:

\begin{lstlisting}
systemctl enable reflector.timer
\end{lstlisting}

You can also manually update mirrors:

\begin{lstlisting}
reflector --latest 10 --protocol https --sort rate --save /etc/pacman.d/mirrorlist
\end{lstlisting}

\section{Checkpoint Before Graphical Setup}

âœ… System updated  
âœ… Microcode installed  
âœ… Audio working via pipewire  
âœ… Graphics drivers installed  
âœ… Bluetooth and printing services ready  
âœ… Fonts and terminal tools in place  

You're now ready for a display server and a desktop environment â€” a throne for your new OS.

\clearpage


\chapter{Graphical Environment Setup}

\section*{CLI is Pure, But GUI is Useful}

Yes, the terminal is a sacred rite. But there comes a time to bless your Arch system with **vision** â€” a graphical environment.

In this chapter:

\begin{enumerate}
  \item Weâ€™ll install a display server (Wayland-first, X11 optional)
  \item Choose a desktop environment or window manager
  \item Set up a display/login manager or `startx`
\end{enumerate}

\section{Wayland is Now}

Wayland is no longer the future â€” itâ€™s the present. Itâ€™s the default for GNOME, KDE Plasma, and others.

X11 is still supported, but it's only used:
\begin{itemize}
  \item For legacy apps or WMs
  \item When Wayland has known compatibility issues
\end{itemize}

Unless you have a specific need, stick to **Wayland**.

\section{Installing Wayland (if not bundled)}

Most DEs (GNOME, KDE) bring Wayland along. But to be explicit:

\begin{lstlisting}
pacman -S wayland xdg-desktop-portal xdg-desktop-portal-wlr
\end{lstlisting}

Note: Some portals are DE-specific â€” GNOME/KDE pull their own.

\section{Installing a Desktop Environment (Wayland-First Choices)}

\subsection*{Option A: KDE Plasma 6 (Now Wayland by Default)}

\begin{lstlisting}
pacman -S plasma-meta kde-applications qt6-wayland
pacman -S sddm
systemctl enable sddm
\end{lstlisting}

Wayland will be default. If you ever want to switch to X11, just select it from the SDDM session menu.

\subsection*{Option B: GNOME (Wayland Default)}

\begin{lstlisting}
pacman -S gnome gnome-extra
systemctl enable gdm
\end{lstlisting}

GDM launches into Wayland by default. No config needed.

\subsection*{Option C: Sway (Wayland-native i3 Alternative)}

\begin{lstlisting}
pacman -S sway alacritty foot wl-clipboard xwayland
\end{lstlisting}

Sway is a tiling window manager for Wayland. `xwayland` allows legacy X apps to run.

You can launch Sway from TTY:

\begin{lstlisting}
exec sway
\end{lstlisting}

\subsection*{Option D: XFCE (X11 Only, for Now)}

\begin{lstlisting}
pacman -S xfce4 xfce4-goodies
pacman -S lightdm lightdm-gtk-greeter
systemctl enable lightdm
\end{lstlisting}

Still stuck on X11, but extremely lightweight.

\section{Display Manager vs startx}

- A **Display Manager** gives you a GUI login screen.
- `startx` (X11) or `exec sway` (Wayland) are CLI launch options.

If you're using GNOME or KDE: use GDM or SDDM.  
If using a Wayland WM like Sway, you can launch manually from TTY.

\subsection*{Make GUI login default:}

\begin{lstlisting}
systemctl set-default graphical.target
\end{lstlisting}

\section{Fonts and Themes}

Always install fonts before launching a DE:

\begin{lstlisting}
pacman -S ttf-dejavu ttf-liberation noto-fonts ttf-nerd-fonts-symbols
\end{lstlisting}

GTK/Qt Theme config:

\begin{lstlisting}
pacman -S lxappearance qt5ct qt6ct
\end{lstlisting}

\section{Post-DE Checklist}

âœ… Wayland installed and used by default  
âœ… GNOME/KDE auto-launch with GDM/SDDM  
âœ… Fonts and themes configured  
âœ… Display target set to graphical  
âœ… You can launch into GUI on boot (or via TTY for Sway)

You now wield a **Wayland-powered** desktop Arch system. You didnâ€™t just install an OS â€” you cultivated a kingdom.

\clearpage

\end{document}
